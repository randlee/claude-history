package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

func TestExport_FullWorkflow_HTML(t *testing.T) {
	// Create test project with realistic data
	tmpDir, projectDir, projectPath := setupTestProject(t, "html-export-test")

	// Create session with 3 agents
	sessionID := createTestSessionWithAgents(t, projectDir, 3)

	// Set up command flags
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	outputDir := filepath.Join(tmpDir, "export-output")

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = outputDir
	claudeDir = tmpDir

	// Run export
	err := runExport(exportCmd, []string{projectPath})
	if err != nil {
		t.Fatalf("Export failed: %v", err)
	}

	// Verify all expected files are present
	verifyHTMLOutput(t, outputDir, 3)

	// Verify index.html is valid
	indexPath := filepath.Join(outputDir, "index.html")
	doc := parseHTML(t, indexPath)

	// Verify HTML structure
	htmlNode := findHTMLNode(doc, "html")
	if htmlNode == nil {
		t.Error("HTML document missing <html> tag")
	}

	headNode := findHTMLNode(doc, "head")
	if headNode == nil {
		t.Error("HTML document missing <head> tag")
	}

	bodyNode := findHTMLNode(doc, "body")
	if bodyNode == nil {
		t.Error("HTML document missing <body> tag")
	}

	// Verify manifest is valid
	manifestPath := filepath.Join(outputDir, "manifest.json")
	manifest := verifyManifestValid(t, manifestPath)

	// Check manifest has correct session ID
	if manifestSessionID, ok := manifest["session_id"].(string); ok {
		if manifestSessionID != sessionID {
			t.Errorf("manifest session_id = %s, want %s", manifestSessionID, sessionID)
		}
	} else {
		t.Error("manifest missing or invalid session_id")
	}

	// Verify source files were copied
	sourceDir := filepath.Join(outputDir, "source")
	sessionFile := filepath.Join(sourceDir, "session.jsonl")
	if _, err := os.Stat(sessionFile); os.IsNotExist(err) {
		t.Error("source session.jsonl not found")
	}
}

func TestExport_FullWorkflow_JSONL(t *testing.T) {
	// Create test project
	tmpDir, projectDir, projectPath := setupTestProject(t, "jsonl-export-test")

	// Create session with agents
	sessionID := createTestSessionWithAgents(t, projectDir, 2)

	// Set up command flags
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	outputDir := filepath.Join(tmpDir, "export-jsonl")

	exportSessionID = sessionID
	exportFormat = "jsonl"
	exportOutputDir = outputDir
	claudeDir = tmpDir

	// Run export
	err := runExport(exportCmd, []string{projectPath})
	if err != nil {
		t.Fatalf("JSONL export failed: %v", err)
	}

	// Verify source directory exists
	sourceDir := filepath.Join(outputDir, "source")
	if _, err := os.Stat(sourceDir); os.IsNotExist(err) {
		t.Error("source directory not created")
	}

	// Verify session file was copied
	sessionFile := filepath.Join(sourceDir, "session.jsonl")
	if _, err := os.Stat(sessionFile); os.IsNotExist(err) {
		t.Error("session.jsonl not copied")
	}

	// Verify agent files were copied
	agentsDir := filepath.Join(sourceDir, "agents")
	if _, err := os.Stat(agentsDir); os.IsNotExist(err) {
		t.Error("agents directory not created")
	}

	// For JSONL format, HTML files should NOT be created
	indexPath := filepath.Join(outputDir, "index.html")
	if _, err := os.Stat(indexPath); !os.IsNotExist(err) {
		t.Error("index.html should not be created for JSONL format")
	}
}

func TestExport_AutoGeneratedOutputDir(t *testing.T) {
	// Create test project
	tmpDir, projectDir, projectPath := setupTestProject(t, "auto-output-test")

	// Create session
	sessionID := createTestSessionWithAgents(t, projectDir, 1)

	// Set up command flags - no output directory specified
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = "" // Auto-generate
	claudeDir = tmpDir

	// Run export
	err := runExport(exportCmd, []string{projectPath})
	if err != nil {
		t.Fatalf("Export with auto-generated output failed: %v", err)
	}

	// The auto-generated path should be in temp directory
	// We can't easily verify the exact path, but the command should succeed
	// and print the output directory to stdout
}

func TestExport_CustomOutputDir(t *testing.T) {
	// Create test project
	tmpDir, projectDir, projectPath := setupTestProject(t, "custom-output-test")

	// Create session
	sessionID := createTestSessionWithAgents(t, projectDir, 1)

	// Set up command flags with custom output
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	customOutput := filepath.Join(tmpDir, "my-custom-export")

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = customOutput
	claudeDir = tmpDir

	// Run export
	err := runExport(exportCmd, []string{projectPath})
	if err != nil {
		t.Fatalf("Export to custom directory failed: %v", err)
	}

	// Verify files created in custom location
	if _, err := os.Stat(customOutput); os.IsNotExist(err) {
		t.Error("custom output directory not created")
	}

	indexPath := filepath.Join(customOutput, "index.html")
	if _, err := os.Stat(indexPath); os.IsNotExist(err) {
		t.Error("index.html not created in custom directory")
	}
}

func TestExport_NestedAgents(t *testing.T) {
	// Create test project with nested agent structure
	tmpDir, projectDir, projectPath := setupTestProject(t, "nested-agents-test")

	// Create main session
	sessionID := createTestSessionWithAgents(t, projectDir, 1)

	// Add nested agent structure
	createNestedAgentStructure(t, projectDir, sessionID)

	// Set up command flags
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	outputDir := filepath.Join(tmpDir, "export-nested")

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = outputDir
	claudeDir = tmpDir

	// Run export
	err := runExport(exportCmd, []string{projectPath})
	if err != nil {
		t.Fatalf("Export with nested agents failed: %v", err)
	}

	// Verify all agent HTML files created (1 initial + 1 parent + 2 children = 4 total)
	verifyHTMLOutput(t, outputDir, 4)

	// Verify manifest includes agent hierarchy
	manifestPath := filepath.Join(outputDir, "manifest.json")
	manifest := verifyManifestValid(t, manifestPath)

	// Check agent tree structure
	if agentTree, ok := manifest["agent_tree"].(map[string]interface{}); ok {
		if children, ok := agentTree["children"].([]interface{}); ok {
			if len(children) == 0 {
				t.Error("manifest agent_tree should have children")
			}
		}
	} else {
		t.Error("manifest missing agent_tree")
	}
}

func TestExport_EmptySession(t *testing.T) {
	// Create test project with minimal session
	tmpDir, projectDir, projectPath := setupTestProject(t, "empty-session-test")

	// Create empty session
	sessionID := createEmptySession(t, projectDir)

	// Set up command flags
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	outputDir := filepath.Join(tmpDir, "export-empty")

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = outputDir
	claudeDir = tmpDir

	// Run export - should succeed
	err := runExport(exportCmd, []string{projectPath})
	if err != nil {
		t.Fatalf("Export of empty session failed: %v", err)
	}

	// Verify basic files created
	indexPath := filepath.Join(outputDir, "index.html")
	if _, err := os.Stat(indexPath); os.IsNotExist(err) {
		t.Error("index.html not created for empty session")
	}

	// HTML should be valid even with minimal content
	doc := parseHTML(t, indexPath)
	if doc == nil {
		t.Error("empty session HTML is invalid")
	}
}

func TestExport_NoAgents(t *testing.T) {
	// Create test project with session but no agents
	tmpDir, projectDir, projectPath := setupTestProject(t, "no-agents-test")

	// Create session with 0 agents
	sessionID := createTestSessionWithAgents(t, projectDir, 0)

	// Set up command flags
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	outputDir := filepath.Join(tmpDir, "export-no-agents")

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = outputDir
	claudeDir = tmpDir

	// Run export
	err := runExport(exportCmd, []string{projectPath})
	if err != nil {
		t.Fatalf("Export with no agents failed: %v", err)
	}

	// Should succeed with no agents directory
	agentsDir := filepath.Join(outputDir, "agents")
	if _, err := os.Stat(agentsDir); !os.IsNotExist(err) {
		// Directory might exist but should be empty
		entries, _ := os.ReadDir(agentsDir)
		htmlCount := 0
		for _, entry := range entries {
			if strings.HasSuffix(entry.Name(), ".html") {
				htmlCount++
			}
		}
		if htmlCount > 0 {
			t.Errorf("expected 0 agent HTML files, found %d", htmlCount)
		}
	}
}

func TestExport_MissingAgentFiles(t *testing.T) {
	// Create test project
	tmpDir, projectDir, projectPath := setupTestProject(t, "missing-agents-test")

	sessionID := "missing-agents-session"

	// Create session file with queue-operation for agent, but don't create the agent file
	sessionContent := fmt.Sprintf(`{"type":"user","timestamp":"2026-02-01T10:00:00Z","sessionId":"%s","uuid":"entry-1","message":"Test"}
{"type":"queue-operation","timestamp":"2026-02-01T10:01:00Z","sessionId":"%s","uuid":"queue-1","agentId":"missing-agent"}
`, sessionID, sessionID)

	sessionFile := filepath.Join(projectDir, sessionID+".jsonl")
	if err := os.WriteFile(sessionFile, []byte(sessionContent), 0644); err != nil {
		t.Fatalf("failed to create session file: %v", err)
	}

	// Do NOT create the agent file - simulate missing agent

	// Set up command flags
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	outputDir := filepath.Join(tmpDir, "export-missing")

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = outputDir
	claudeDir = tmpDir

	// Run export - should succeed but may have warnings
	err := runExport(exportCmd, []string{projectPath})
	if err != nil {
		// Export might fail or succeed with warnings
		// As long as main session is exported, that's acceptable
		t.Logf("Export with missing agent files: %v", err)
	}

	// Main session should still be exported
	indexPath := filepath.Join(outputDir, "index.html")
	if _, err := os.Stat(indexPath); os.IsNotExist(err) {
		t.Error("index.html should be created even with missing agents")
	}
}

func TestExport_RelativePath(t *testing.T) {
	// Test with relative project path
	tmpDir, projectDir, _ := setupTestProject(t, "relative-path-test")

	sessionID := createTestSessionWithAgents(t, projectDir, 1)

	// Set up command flags
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	outputDir := filepath.Join(tmpDir, "export-relative")

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = outputDir
	claudeDir = tmpDir

	// Change to temp directory to test relative path
	oldWd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get working directory: %v", err)
	}
	defer func() { _ = os.Chdir(oldWd) }()

	if err := os.Chdir(tmpDir); err != nil {
		t.Fatalf("failed to change directory: %v", err)
	}

	// Use relative path for project
	relativePath := "relative-path-test"

	// Run export with relative path
	err = runExport(exportCmd, []string{relativePath})
	if err != nil {
		t.Fatalf("Export with relative path failed: %v", err)
	}

	// Verify output created
	if _, err := os.Stat(outputDir); os.IsNotExist(err) {
		t.Error("output directory not created for relative path export")
	}
}

func TestExport_CurrentDirectory(t *testing.T) {
	// Test exporting from current directory (no path argument)
	tmpDir, projectDir, projectPath := setupTestProject(t, "current-dir-test")

	sessionID := createTestSessionWithAgents(t, projectDir, 1)

	// Set up command flags
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	outputDir := filepath.Join(tmpDir, "export-curdir")

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = outputDir
	claudeDir = tmpDir

	// Change to project path
	oldWd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get working directory: %v", err)
	}
	defer func() { _ = os.Chdir(oldWd) }()

	if err := os.Chdir(projectPath); err != nil {
		t.Fatalf("failed to change to project directory: %v", err)
	}

	// Run export with no path argument (should use current directory)
	err = runExport(exportCmd, []string{})
	if err != nil {
		t.Fatalf("Export from current directory failed: %v", err)
	}

	// Verify output created
	if _, err := os.Stat(outputDir); os.IsNotExist(err) {
		t.Error("output directory not created for current directory export")
	}
}

func TestExport_TimestampInPath(t *testing.T) {
	// Test that auto-generated paths include timestamp
	tmpDir, projectDir, projectPath := setupTestProject(t, "timestamp-test")

	sessionID := createTestSessionWithAgents(t, projectDir, 1)

	// Set up command flags
	oldSessionID := exportSessionID
	oldFormat := exportFormat
	oldOutputDir := exportOutputDir
	oldClaudeDir := claudeDir
	defer func() {
		exportSessionID = oldSessionID
		exportFormat = oldFormat
		exportOutputDir = oldOutputDir
		claudeDir = oldClaudeDir
	}()

	exportSessionID = sessionID
	exportFormat = "html"
	exportOutputDir = "" // Auto-generate with timestamp
	claudeDir = tmpDir

	// Run export twice with small delay
	err1 := runExport(exportCmd, []string{projectPath})
	if err1 != nil {
		t.Fatalf("First export failed: %v", err1)
	}

	// Wait to ensure different timestamp
	time.Sleep(2 * time.Second)

	err2 := runExport(exportCmd, []string{projectPath})
	if err2 != nil {
		t.Fatalf("Second export failed: %v", err2)
	}

	// Both should succeed and create different directories
	// (We can't easily verify they're different without capturing stdout,
	// but the lack of errors indicates the timestamp mechanism works)
}
